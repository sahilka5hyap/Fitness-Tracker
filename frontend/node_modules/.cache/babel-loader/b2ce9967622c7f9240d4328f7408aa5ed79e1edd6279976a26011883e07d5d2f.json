{"ast":null,"code":"var _excluded = [\"id\"],\n  _excluded2 = [\"type\", \"layout\", \"connectNulls\", \"needClip\", \"shape\"],\n  _excluded3 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\", \"id\"];\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nimport * as React from 'react';\nimport { Component, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { interpolate, isNullish } from '../util/DataUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { SetErrorBarContext } from '../context/ErrorBarContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { useChartLayout } from '../context/chartLayoutContext';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { Shape } from '../util/ActiveShapeUtils';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n\n/**\r\n * Internal props, combination of external props + defaultProps + private Recharts state\r\n */\n\n/**\r\n * External props, intended for end users to fill in\r\n */\n\n/**\r\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\r\n */\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: stroke,\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nvar SetLineTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    positions: undefined,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: stroke,\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n};\nfunction repeat(lines, count) {\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\n  var result = [];\n  for (var i = 0; i < count; ++i) {\n    result = [...result, ...linesUnit];\n  }\n  return result;\n}\nvar getStrokeDasharray = (length, totalLength, lines) => {\n  var lineLength = lines.reduce((pre, next) => pre + next);\n\n  // if lineLength is 0 return the default when no strokeDasharray is provided\n  if (!lineLength) {\n    return generateSimpleStrokeDasharray(totalLength, length);\n  }\n  var count = Math.floor(length / lineLength);\n  var remainLength = length % lineLength;\n  var restLength = totalLength - length;\n  var remainLines = [];\n  for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {\n    if (sum + lines[i] > remainLength) {\n      remainLines = [...lines.slice(0, i), remainLength - sum];\n      break;\n    }\n  }\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\n};\nfunction LineDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    dot,\n    dataKey,\n    needClip\n  } = props;\n\n  /*\r\n   * Exclude ID from the props passed to the Dots component\r\n   * because then the ID would be applied to multiple dots, and it would no longer be unique.\r\n   */\n  var {\n      id\n    } = props,\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\n  var lineProps = svgPropertiesNoEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-line-dots\",\n    dotClassName: \"recharts-line-dot\",\n    dataKey: dataKey,\n    baseProps: lineProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\nfunction LineLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = useMemo(() => {\n    return points === null || points === void 0 ? void 0 : points.map(point => {\n      var _point$x, _point$y;\n      var viewBox = {\n        x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n        y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n        width: 0,\n        lowerWidth: 0,\n        upperWidth: 0,\n        height: 0\n      };\n      return _objectSpread(_objectSpread({}, viewBox), {}, {\n        value: point.value,\n        payload: point.payload,\n        viewBox,\n        /*\r\n         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?\r\n         * Or should this just be the root chart viewBox?\r\n         */\n        parentViewBox: undefined,\n        fill: undefined\n      });\n    });\n  }, [points]);\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction StaticCurve(_ref4) {\n  var {\n    clipPathId,\n    pathRef,\n    points,\n    strokeDasharray,\n    props\n  } = _ref4;\n  var {\n      type,\n      layout,\n      connectNulls,\n      needClip,\n      shape\n    } = props,\n    others = _objectWithoutProperties(props, _excluded2);\n  var curveProps = _objectSpread(_objectSpread({}, svgPropertiesAndEvents(others)), {}, {\n    fill: 'none',\n    className: 'recharts-line-curve',\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined,\n    points,\n    type,\n    layout,\n    connectNulls,\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Shape, _extends({\n    shapeType: \"curve\",\n    option: shape\n  }, curveProps, {\n    pathRef: pathRef\n  })), /*#__PURE__*/React.createElement(LineDotsWrapper, {\n    points: points,\n    clipPathId: clipPathId,\n    props: props\n  }));\n}\nfunction getTotalLength(mainCurve) {\n  try {\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\n  } catch (_unused) {\n    return 0;\n  }\n}\nfunction CurveWithAnimation(_ref5) {\n  var {\n    clipPathId,\n    props,\n    pathRef,\n    previousPointsRef,\n    longestAnimatedLengthRef\n  } = _ref5;\n  var {\n    points,\n    strokeDasharray,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    animateNewValues,\n    width,\n    height,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var prevPoints = previousPointsRef.current;\n  var animationId = useAnimationId(points, 'recharts-line-');\n  var animationIdRef = useRef(animationId);\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var totalLength = getTotalLength(pathRef.current);\n  /*\r\n   * Here we want to detect if the length animation has been interrupted.\r\n   * For that we keep a reference to the furthest length that has been animated.\r\n   *\r\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\r\n   *\r\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\r\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\r\n   *\r\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\r\n   * and makes it stand out. But it's good enough I suppose.\r\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\r\n   *\r\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\r\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\r\n   * change the dataKey and the Line will continue growing from where it has grown so far.\r\n   *\r\n   * This is for the case when new animation triggers. When that happens we get new points, everything re-renders,\r\n   * and we get fresh new state in this component and use the ref stored above.\r\n   *\r\n   * In case when we get render without new animation - for example when opacity changes, or color changes,\r\n   * then the animationId remains the same, and we do not update the starting point.\r\n   * See https://github.com/recharts/recharts/issues/6044\r\n   */\n  var startingPointRef = useRef(0);\n  if (animationIdRef.current !== animationId) {\n    startingPointRef.current = longestAnimatedLengthRef.current;\n    animationIdRef.current = animationId;\n  }\n  var startingPoint = startingPointRef.current;\n  return /*#__PURE__*/React.createElement(LineLabelListProvider, {\n    points: points,\n    showLabels: showLabels\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    var lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);\n    var curLength = Math.min(lengthInterpolated, totalLength);\n    var currentStrokeDasharray;\n    if (isAnimationActive) {\n      if (strokeDasharray) {\n        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\n        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\n      } else {\n        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\n      }\n    } else {\n      currentStrokeDasharray = strokeDasharray == null ? undefined : String(strokeDasharray);\n    }\n\n    /*\r\n     * Here it is important to wait a little bit with updating the previousPointsRef\r\n     * before the animation has a time to initialize.\r\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\r\n     * and before pathRef is set.\r\n     * If that happens, the Line will re-render again after Legend had reported its height\r\n     * which will start a new animation with the previous points as the starting point\r\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\r\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\r\n     *\r\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\r\n     * before the pathRef is set, otherwise we will have a wrong total length.\r\n     */\n    if (t > 0 && totalLength > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      /*\r\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\r\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\r\n       * however the same happens when the data change.\r\n       *\r\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\r\n       *\r\n       * Therefore the totalLength > 0 check.\r\n       *\r\n       * The Animate is about to fire handleAnimationStart which will update the state\r\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\r\n       * and update the longestAnimatedLengthRef.\r\n       *\r\n       * Why Math.max? Sometimes the curve goes through a smaller length than previously recorded.\r\n       * If we just set it to curLength, then the next animation would start from a smaller length\r\n       * which looks weird. So we keep the longest length ever reached and then animate from there.\r\n       */\n      // eslint-disable-next-line no-param-reassign\n      longestAnimatedLengthRef.current = Math.max(longestAnimatedLengthRef.current, curLength);\n    }\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepData = t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n\n        // magic number of faking previous x and y location\n        if (animateNewValues) {\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(width * 2, entry.x, t),\n            y: interpolate(height / 2, entry.y, t)\n          });\n        }\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          x: entry.x,\n          y: entry.y\n        });\n      });\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = stepData;\n      return /*#__PURE__*/React.createElement(StaticCurve, {\n        props: props,\n        points: stepData,\n        clipPathId: clipPathId,\n        pathRef: pathRef,\n        strokeDasharray: currentStrokeDasharray\n      });\n    }\n    return /*#__PURE__*/React.createElement(StaticCurve, {\n      props: props,\n      points: points,\n      clipPathId: clipPathId,\n      pathRef: pathRef,\n      strokeDasharray: currentStrokeDasharray\n    });\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\nfunction RenderCurve(_ref6) {\n  var {\n    clipPathId,\n    props\n  } = _ref6;\n  var previousPointsRef = useRef(null);\n  var longestAnimatedLengthRef = useRef(0);\n  var pathRef = useRef(null);\n  return /*#__PURE__*/React.createElement(CurveWithAnimation, {\n    props: props,\n    clipPathId: clipPathId,\n    previousPointsRef: previousPointsRef,\n    longestAnimatedLengthRef: longestAnimatedLengthRef,\n    pathRef: pathRef\n  });\n}\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\n  var _dataPoint$x, _dataPoint$y;\n  return {\n    x: (_dataPoint$x = dataPoint.x) !== null && _dataPoint$x !== void 0 ? _dataPoint$x : undefined,\n    y: (_dataPoint$y = dataPoint.y) !== null && _dataPoint$y !== void 0 ? _dataPoint$y : undefined,\n    value: dataPoint.value,\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n  };\n};\n\n// eslint-disable-next-line react/prefer-stateless-function\nclass LineWithState extends Component {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      xAxisId,\n      yAxisId,\n      top,\n      left,\n      width,\n      height,\n      id,\n      needClip,\n      zIndex\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-line', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(SetErrorBarContext, {\n      xAxisId: xAxisId,\n      yAxisId: yAxisId,\n      data: points,\n      dataPointFormatter: errorBarDataPointFormatter,\n      errorBarOffset: 0\n    }, /*#__PURE__*/React.createElement(RenderCurve, {\n      props: this.props,\n      clipPathId: clipPathId\n    }))), /*#__PURE__*/React.createElement(ActivePoints, {\n      activeDot: this.props.activeDot,\n      points: points,\n      mainColor: this.props.stroke,\n      itemDataKey: this.props.dataKey,\n      clipPath: activePointsClipPath\n    }));\n  }\n}\nexport var defaultLineProps = {\n  activeDot: true,\n  animateNewValues: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: true,\n  fill: '#fff',\n  hide: false,\n  isAnimationActive: 'auto',\n  label: false,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.line,\n  type: 'linear'\n};\nfunction LineImpl(props) {\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\n    {\n      activeDot,\n      animateNewValues,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      hide,\n      isAnimationActive,\n      label,\n      legendType,\n      xAxisId,\n      yAxisId,\n      id\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded3);\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var plotArea = usePlotArea();\n  var layout = useChartLayout();\n  var isPanorama = useIsPanorama();\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));\n  if (layout !== 'horizontal' && layout !== 'vertical' || points == null || plotArea == null) {\n    // Cannot render Line in an unsupported layout\n    return null;\n  }\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\n    id: id,\n    connectNulls: connectNulls,\n    dot: dot,\n    activeDot: activeDot,\n    animateNewValues: animateNewValues,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    isAnimationActive: isAnimationActive,\n    hide: hide,\n    label: label,\n    legendType: legendType,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId,\n    points: points,\n    layout: layout,\n    height: height,\n    width: width,\n    left: left,\n    top: top,\n    needClip: needClip\n  }));\n}\nexport function computeLinePoints(_ref7) {\n  var {\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  } = _ref7;\n  return displayedData.map((entry, index) => {\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    var value = getValueByDataKey(entry, dataKey);\n    if (layout === 'horizontal') {\n      var _x = getCateCoordinateOfLine({\n        axis: xAxis,\n        ticks: xAxisTicks,\n        bandSize,\n        entry,\n        index\n      });\n      var _y = isNullish(value) ? null : yAxis.scale(value);\n      return {\n        x: _x,\n        y: _y,\n        value,\n        payload: entry\n      };\n    }\n    var x = isNullish(value) ? null : xAxis.scale(value);\n    var y = getCateCoordinateOfLine({\n      axis: yAxis,\n      ticks: yAxisTicks,\n      bandSize,\n      entry,\n      index\n    });\n    if (x == null || y == null) {\n      return null;\n    }\n    return {\n      x,\n      y,\n      value,\n      payload: entry\n    };\n  }).filter(Boolean);\n}\nfunction LineFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultLineProps);\n  var isPanorama = useIsPanorama();\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"line\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetLineTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"line\",\n    id: id,\n    data: props.data,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    dataKey: props.dataKey,\n    hide: props.hide,\n    isPanorama: isPanorama\n  }), /*#__PURE__*/React.createElement(LineImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n\n/**\r\n * @provides LabelListContext\r\n * @provides ErrorBarContext\r\n * @consumes CartesianChartContext\r\n */\nexport var Line = /*#__PURE__*/React.memo(LineFn, propsAreEqual);\nLine.displayName = 'Line';","map":{"version":3,"names":["_excluded","_excluded2","_excluded3","_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_objectWithoutProperties","_objectWithoutPropertiesLoose","indexOf","propertyIsEnumerable","React","Component","useCallback","useMemo","useRef","useState","clsx","Layer","CartesianLabelListContextProvider","LabelListFromLabelProp","Dots","interpolate","isNullish","isClipDot","getCateCoordinateOfLine","getTooltipNameProp","getValueByDataKey","ActivePoints","SetTooltipEntrySettings","SetErrorBarContext","GraphicalItemClipPath","useNeedsClip","useChartLayout","useIsPanorama","selectLinePoints","useAppSelector","SetLegendPayload","useAnimationId","resolveDefaultProps","usePlotArea","RegisterGraphicalItemId","SetCartesianGraphicalItem","svgPropertiesNoEvents","JavascriptAnimate","svgPropertiesAndEvents","getRadiusAndStrokeWidthFromDot","Shape","ZIndexLayer","DefaultZIndexes","propsAreEqual","computeLegendPayloadFromAreaData","props","dataKey","name","stroke","legendType","hide","inactive","type","color","payload","SetLineTooltipEntrySettings","memo","_ref","data","strokeWidth","fill","unit","tooltipType","id","tooltipEntrySettings","dataDefinedOnItem","positions","undefined","settings","nameKey","graphicalItemId","createElement","generateSimpleStrokeDasharray","totalLength","concat","repeat","lines","count","linesUnit","result","getStrokeDasharray","lineLength","reduce","pre","next","Math","floor","remainLength","restLength","remainLines","sum","slice","emptyLines","map","line","join","LineDotsWrapper","_ref2","clipPathId","points","dot","needClip","propsWithoutId","lineProps","className","dotClassName","baseProps","LineLabelListProvider","_ref3","showLabels","children","labelListEntries","point","_point$x","_point$y","viewBox","x","y","width","lowerWidth","upperWidth","height","parentViewBox","StaticCurve","_ref4","pathRef","strokeDasharray","layout","connectNulls","shape","others","curveProps","clipPath","Fragment","shapeType","option","getTotalLength","mainCurve","_unused","CurveWithAnimation","_ref5","previousPointsRef","longestAnimatedLengthRef","isAnimationActive","animationBegin","animationDuration","animationEasing","animateNewValues","onAnimationEnd","onAnimationStart","prevPoints","current","animationId","animationIdRef","isAnimating","setIsAnimating","handleAnimationEnd","handleAnimationStart","startingPointRef","startingPoint","begin","duration","isActive","easing","key","lengthInterpolated","curLength","min","currentStrokeDasharray","split","num","parseFloat","max","prevPointsDiffFactor","stepData","entry","index","prevPointIndex","prev","label","RenderCurve","_ref6","errorBarDataPointFormatter","dataPoint","_dataPoint$x","_dataPoint$y","errorVal","LineWithState","render","xAxisId","yAxisId","top","left","zIndex","layerClass","clipDot","dotSize","activePointsClipPath","dataPointFormatter","errorBarOffset","activeDot","mainColor","itemDataKey","defaultLineProps","LineImpl","_resolveDefaultProps","everythingElse","plotArea","isPanorama","state","computeLinePoints","_ref7","xAxis","yAxis","xAxisTicks","yAxisTicks","bandSize","displayedData","_x","axis","ticks","_y","scale","Boolean","LineFn","outsideProps","legendPayload","zAxisId","Line","displayName"],"sources":["C:/Users/sahil/OneDrive/Desktop/sample/GeminiAI/frontend/node_modules/recharts/es6/cartesian/Line.js"],"sourcesContent":["var _excluded = [\"id\"],\r\n  _excluded2 = [\"type\", \"layout\", \"connectNulls\", \"needClip\", \"shape\"],\r\n  _excluded3 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\", \"id\"];\r\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\r\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\r\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\r\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\r\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\r\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\r\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\r\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\r\nimport * as React from 'react';\r\nimport { Component, useCallback, useMemo, useRef, useState } from 'react';\r\nimport { clsx } from 'clsx';\r\nimport { Layer } from '../container/Layer';\r\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\r\nimport { Dots } from '../component/Dots';\r\nimport { interpolate, isNullish } from '../util/DataUtils';\r\nimport { isClipDot } from '../util/ReactUtils';\r\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\r\nimport { ActivePoints } from '../component/ActivePoints';\r\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\r\nimport { SetErrorBarContext } from '../context/ErrorBarContext';\r\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\r\nimport { useChartLayout } from '../context/chartLayoutContext';\r\nimport { useIsPanorama } from '../context/PanoramaContext';\r\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\r\nimport { useAppSelector } from '../state/hooks';\r\nimport { SetLegendPayload } from '../state/SetLegendPayload';\r\nimport { useAnimationId } from '../util/useAnimationId';\r\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\r\nimport { usePlotArea } from '../hooks';\r\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\r\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\r\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\r\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\r\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\r\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\r\nimport { Shape } from '../util/ActiveShapeUtils';\r\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\r\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\r\nimport { propsAreEqual } from '../util/propsAreEqual';\r\n\r\n/**\r\n * Internal props, combination of external props + defaultProps + private Recharts state\r\n */\r\n\r\n/**\r\n * External props, intended for end users to fill in\r\n */\r\n\r\n/**\r\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\r\n */\r\n\r\nvar computeLegendPayloadFromAreaData = props => {\r\n  var {\r\n    dataKey,\r\n    name,\r\n    stroke,\r\n    legendType,\r\n    hide\r\n  } = props;\r\n  return [{\r\n    inactive: hide,\r\n    dataKey,\r\n    type: legendType,\r\n    color: stroke,\r\n    value: getTooltipNameProp(name, dataKey),\r\n    payload: props\r\n  }];\r\n};\r\nvar SetLineTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\r\n  var {\r\n    dataKey,\r\n    data,\r\n    stroke,\r\n    strokeWidth,\r\n    fill,\r\n    name,\r\n    hide,\r\n    unit,\r\n    tooltipType,\r\n    id\r\n  } = _ref;\r\n  var tooltipEntrySettings = {\r\n    dataDefinedOnItem: data,\r\n    positions: undefined,\r\n    settings: {\r\n      stroke,\r\n      strokeWidth,\r\n      fill,\r\n      dataKey,\r\n      nameKey: undefined,\r\n      name: getTooltipNameProp(name, dataKey),\r\n      hide,\r\n      type: tooltipType,\r\n      color: stroke,\r\n      unit,\r\n      graphicalItemId: id\r\n    }\r\n  };\r\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\r\n    tooltipEntrySettings: tooltipEntrySettings\r\n  });\r\n});\r\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\r\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\r\n};\r\nfunction repeat(lines, count) {\r\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\r\n  var result = [];\r\n  for (var i = 0; i < count; ++i) {\r\n    result = [...result, ...linesUnit];\r\n  }\r\n  return result;\r\n}\r\nvar getStrokeDasharray = (length, totalLength, lines) => {\r\n  var lineLength = lines.reduce((pre, next) => pre + next);\r\n\r\n  // if lineLength is 0 return the default when no strokeDasharray is provided\r\n  if (!lineLength) {\r\n    return generateSimpleStrokeDasharray(totalLength, length);\r\n  }\r\n  var count = Math.floor(length / lineLength);\r\n  var remainLength = length % lineLength;\r\n  var restLength = totalLength - length;\r\n  var remainLines = [];\r\n  for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {\r\n    if (sum + lines[i] > remainLength) {\r\n      remainLines = [...lines.slice(0, i), remainLength - sum];\r\n      break;\r\n    }\r\n  }\r\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\r\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\r\n};\r\nfunction LineDotsWrapper(_ref2) {\r\n  var {\r\n    clipPathId,\r\n    points,\r\n    props\r\n  } = _ref2;\r\n  var {\r\n    dot,\r\n    dataKey,\r\n    needClip\r\n  } = props;\r\n\r\n  /*\r\n   * Exclude ID from the props passed to the Dots component\r\n   * because then the ID would be applied to multiple dots, and it would no longer be unique.\r\n   */\r\n  var {\r\n      id\r\n    } = props,\r\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\r\n  var lineProps = svgPropertiesNoEvents(propsWithoutId);\r\n  return /*#__PURE__*/React.createElement(Dots, {\r\n    points: points,\r\n    dot: dot,\r\n    className: \"recharts-line-dots\",\r\n    dotClassName: \"recharts-line-dot\",\r\n    dataKey: dataKey,\r\n    baseProps: lineProps,\r\n    needClip: needClip,\r\n    clipPathId: clipPathId\r\n  });\r\n}\r\nfunction LineLabelListProvider(_ref3) {\r\n  var {\r\n    showLabels,\r\n    children,\r\n    points\r\n  } = _ref3;\r\n  var labelListEntries = useMemo(() => {\r\n    return points === null || points === void 0 ? void 0 : points.map(point => {\r\n      var _point$x, _point$y;\r\n      var viewBox = {\r\n        x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\r\n        y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\r\n        width: 0,\r\n        lowerWidth: 0,\r\n        upperWidth: 0,\r\n        height: 0\r\n      };\r\n      return _objectSpread(_objectSpread({}, viewBox), {}, {\r\n        value: point.value,\r\n        payload: point.payload,\r\n        viewBox,\r\n        /*\r\n         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?\r\n         * Or should this just be the root chart viewBox?\r\n         */\r\n        parentViewBox: undefined,\r\n        fill: undefined\r\n      });\r\n    });\r\n  }, [points]);\r\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\r\n    value: showLabels ? labelListEntries : undefined\r\n  }, children);\r\n}\r\nfunction StaticCurve(_ref4) {\r\n  var {\r\n    clipPathId,\r\n    pathRef,\r\n    points,\r\n    strokeDasharray,\r\n    props\r\n  } = _ref4;\r\n  var {\r\n      type,\r\n      layout,\r\n      connectNulls,\r\n      needClip,\r\n      shape\r\n    } = props,\r\n    others = _objectWithoutProperties(props, _excluded2);\r\n  var curveProps = _objectSpread(_objectSpread({}, svgPropertiesAndEvents(others)), {}, {\r\n    fill: 'none',\r\n    className: 'recharts-line-curve',\r\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined,\r\n    points,\r\n    type,\r\n    layout,\r\n    connectNulls,\r\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\r\n  });\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Shape, _extends({\r\n    shapeType: \"curve\",\r\n    option: shape\r\n  }, curveProps, {\r\n    pathRef: pathRef\r\n  })), /*#__PURE__*/React.createElement(LineDotsWrapper, {\r\n    points: points,\r\n    clipPathId: clipPathId,\r\n    props: props\r\n  }));\r\n}\r\nfunction getTotalLength(mainCurve) {\r\n  try {\r\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\r\n  } catch (_unused) {\r\n    return 0;\r\n  }\r\n}\r\nfunction CurveWithAnimation(_ref5) {\r\n  var {\r\n    clipPathId,\r\n    props,\r\n    pathRef,\r\n    previousPointsRef,\r\n    longestAnimatedLengthRef\r\n  } = _ref5;\r\n  var {\r\n    points,\r\n    strokeDasharray,\r\n    isAnimationActive,\r\n    animationBegin,\r\n    animationDuration,\r\n    animationEasing,\r\n    animateNewValues,\r\n    width,\r\n    height,\r\n    onAnimationEnd,\r\n    onAnimationStart\r\n  } = props;\r\n  var prevPoints = previousPointsRef.current;\r\n  var animationId = useAnimationId(points, 'recharts-line-');\r\n  var animationIdRef = useRef(animationId);\r\n  var [isAnimating, setIsAnimating] = useState(false);\r\n  var showLabels = !isAnimating;\r\n  var handleAnimationEnd = useCallback(() => {\r\n    if (typeof onAnimationEnd === 'function') {\r\n      onAnimationEnd();\r\n    }\r\n    setIsAnimating(false);\r\n  }, [onAnimationEnd]);\r\n  var handleAnimationStart = useCallback(() => {\r\n    if (typeof onAnimationStart === 'function') {\r\n      onAnimationStart();\r\n    }\r\n    setIsAnimating(true);\r\n  }, [onAnimationStart]);\r\n  var totalLength = getTotalLength(pathRef.current);\r\n  /*\r\n   * Here we want to detect if the length animation has been interrupted.\r\n   * For that we keep a reference to the furthest length that has been animated.\r\n   *\r\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\r\n   *\r\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\r\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\r\n   *\r\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\r\n   * and makes it stand out. But it's good enough I suppose.\r\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\r\n   *\r\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\r\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\r\n   * change the dataKey and the Line will continue growing from where it has grown so far.\r\n   *\r\n   * This is for the case when new animation triggers. When that happens we get new points, everything re-renders,\r\n   * and we get fresh new state in this component and use the ref stored above.\r\n   *\r\n   * In case when we get render without new animation - for example when opacity changes, or color changes,\r\n   * then the animationId remains the same, and we do not update the starting point.\r\n   * See https://github.com/recharts/recharts/issues/6044\r\n   */\r\n  var startingPointRef = useRef(0);\r\n  if (animationIdRef.current !== animationId) {\r\n    startingPointRef.current = longestAnimatedLengthRef.current;\r\n    animationIdRef.current = animationId;\r\n  }\r\n  var startingPoint = startingPointRef.current;\r\n  return /*#__PURE__*/React.createElement(LineLabelListProvider, {\r\n    points: points,\r\n    showLabels: showLabels\r\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\r\n    animationId: animationId,\r\n    begin: animationBegin,\r\n    duration: animationDuration,\r\n    isActive: isAnimationActive,\r\n    easing: animationEasing,\r\n    onAnimationEnd: handleAnimationEnd,\r\n    onAnimationStart: handleAnimationStart,\r\n    key: animationId\r\n  }, t => {\r\n    var lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);\r\n    var curLength = Math.min(lengthInterpolated, totalLength);\r\n    var currentStrokeDasharray;\r\n    if (isAnimationActive) {\r\n      if (strokeDasharray) {\r\n        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\r\n        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\r\n      } else {\r\n        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\r\n      }\r\n    } else {\r\n      currentStrokeDasharray = strokeDasharray == null ? undefined : String(strokeDasharray);\r\n    }\r\n\r\n    /*\r\n     * Here it is important to wait a little bit with updating the previousPointsRef\r\n     * before the animation has a time to initialize.\r\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\r\n     * and before pathRef is set.\r\n     * If that happens, the Line will re-render again after Legend had reported its height\r\n     * which will start a new animation with the previous points as the starting point\r\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\r\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\r\n     *\r\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\r\n     * before the pathRef is set, otherwise we will have a wrong total length.\r\n     */\r\n    if (t > 0 && totalLength > 0) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      previousPointsRef.current = points;\r\n      /*\r\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\r\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\r\n       * however the same happens when the data change.\r\n       *\r\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\r\n       *\r\n       * Therefore the totalLength > 0 check.\r\n       *\r\n       * The Animate is about to fire handleAnimationStart which will update the state\r\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\r\n       * and update the longestAnimatedLengthRef.\r\n       *\r\n       * Why Math.max? Sometimes the curve goes through a smaller length than previously recorded.\r\n       * If we just set it to curLength, then the next animation would start from a smaller length\r\n       * which looks weird. So we keep the longest length ever reached and then animate from there.\r\n       */\r\n      // eslint-disable-next-line no-param-reassign\r\n      longestAnimatedLengthRef.current = Math.max(longestAnimatedLengthRef.current, curLength);\r\n    }\r\n    if (prevPoints) {\r\n      var prevPointsDiffFactor = prevPoints.length / points.length;\r\n      var stepData = t === 1 ? points : points.map((entry, index) => {\r\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\r\n        if (prevPoints[prevPointIndex]) {\r\n          var prev = prevPoints[prevPointIndex];\r\n          return _objectSpread(_objectSpread({}, entry), {}, {\r\n            x: interpolate(prev.x, entry.x, t),\r\n            y: interpolate(prev.y, entry.y, t)\r\n          });\r\n        }\r\n\r\n        // magic number of faking previous x and y location\r\n        if (animateNewValues) {\r\n          return _objectSpread(_objectSpread({}, entry), {}, {\r\n            x: interpolate(width * 2, entry.x, t),\r\n            y: interpolate(height / 2, entry.y, t)\r\n          });\r\n        }\r\n        return _objectSpread(_objectSpread({}, entry), {}, {\r\n          x: entry.x,\r\n          y: entry.y\r\n        });\r\n      });\r\n      // eslint-disable-next-line no-param-reassign\r\n      previousPointsRef.current = stepData;\r\n      return /*#__PURE__*/React.createElement(StaticCurve, {\r\n        props: props,\r\n        points: stepData,\r\n        clipPathId: clipPathId,\r\n        pathRef: pathRef,\r\n        strokeDasharray: currentStrokeDasharray\r\n      });\r\n    }\r\n    return /*#__PURE__*/React.createElement(StaticCurve, {\r\n      props: props,\r\n      points: points,\r\n      clipPathId: clipPathId,\r\n      pathRef: pathRef,\r\n      strokeDasharray: currentStrokeDasharray\r\n    });\r\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\r\n    label: props.label\r\n  }));\r\n}\r\nfunction RenderCurve(_ref6) {\r\n  var {\r\n    clipPathId,\r\n    props\r\n  } = _ref6;\r\n  var previousPointsRef = useRef(null);\r\n  var longestAnimatedLengthRef = useRef(0);\r\n  var pathRef = useRef(null);\r\n  return /*#__PURE__*/React.createElement(CurveWithAnimation, {\r\n    props: props,\r\n    clipPathId: clipPathId,\r\n    previousPointsRef: previousPointsRef,\r\n    longestAnimatedLengthRef: longestAnimatedLengthRef,\r\n    pathRef: pathRef\r\n  });\r\n}\r\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\r\n  var _dataPoint$x, _dataPoint$y;\r\n  return {\r\n    x: (_dataPoint$x = dataPoint.x) !== null && _dataPoint$x !== void 0 ? _dataPoint$x : undefined,\r\n    y: (_dataPoint$y = dataPoint.y) !== null && _dataPoint$y !== void 0 ? _dataPoint$y : undefined,\r\n    value: dataPoint.value,\r\n    // @ts-expect-error getValueByDataKey does not validate the output type\r\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\r\n  };\r\n};\r\n\r\n// eslint-disable-next-line react/prefer-stateless-function\r\nclass LineWithState extends Component {\r\n  render() {\r\n    var {\r\n      hide,\r\n      dot,\r\n      points,\r\n      className,\r\n      xAxisId,\r\n      yAxisId,\r\n      top,\r\n      left,\r\n      width,\r\n      height,\r\n      id,\r\n      needClip,\r\n      zIndex\r\n    } = this.props;\r\n    if (hide) {\r\n      return null;\r\n    }\r\n    var layerClass = clsx('recharts-line', className);\r\n    var clipPathId = id;\r\n    var {\r\n      r,\r\n      strokeWidth\r\n    } = getRadiusAndStrokeWidthFromDot(dot);\r\n    var clipDot = isClipDot(dot);\r\n    var dotSize = r * 2 + strokeWidth;\r\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\r\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\r\n      zIndex: zIndex\r\n    }, /*#__PURE__*/React.createElement(Layer, {\r\n      className: layerClass\r\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\r\n      clipPathId: clipPathId,\r\n      xAxisId: xAxisId,\r\n      yAxisId: yAxisId\r\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\r\n      id: \"clipPath-dots-\".concat(clipPathId)\r\n    }, /*#__PURE__*/React.createElement(\"rect\", {\r\n      x: left - dotSize / 2,\r\n      y: top - dotSize / 2,\r\n      width: width + dotSize,\r\n      height: height + dotSize\r\n    }))), /*#__PURE__*/React.createElement(SetErrorBarContext, {\r\n      xAxisId: xAxisId,\r\n      yAxisId: yAxisId,\r\n      data: points,\r\n      dataPointFormatter: errorBarDataPointFormatter,\r\n      errorBarOffset: 0\r\n    }, /*#__PURE__*/React.createElement(RenderCurve, {\r\n      props: this.props,\r\n      clipPathId: clipPathId\r\n    }))), /*#__PURE__*/React.createElement(ActivePoints, {\r\n      activeDot: this.props.activeDot,\r\n      points: points,\r\n      mainColor: this.props.stroke,\r\n      itemDataKey: this.props.dataKey,\r\n      clipPath: activePointsClipPath\r\n    }));\r\n  }\r\n}\r\nexport var defaultLineProps = {\r\n  activeDot: true,\r\n  animateNewValues: true,\r\n  animationBegin: 0,\r\n  animationDuration: 1500,\r\n  animationEasing: 'ease',\r\n  connectNulls: false,\r\n  dot: true,\r\n  fill: '#fff',\r\n  hide: false,\r\n  isAnimationActive: 'auto',\r\n  label: false,\r\n  legendType: 'line',\r\n  stroke: '#3182bd',\r\n  strokeWidth: 1,\r\n  xAxisId: 0,\r\n  yAxisId: 0,\r\n  zIndex: DefaultZIndexes.line,\r\n  type: 'linear'\r\n};\r\nfunction LineImpl(props) {\r\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\r\n    {\r\n      activeDot,\r\n      animateNewValues,\r\n      animationBegin,\r\n      animationDuration,\r\n      animationEasing,\r\n      connectNulls,\r\n      dot,\r\n      hide,\r\n      isAnimationActive,\r\n      label,\r\n      legendType,\r\n      xAxisId,\r\n      yAxisId,\r\n      id\r\n    } = _resolveDefaultProps,\r\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded3);\r\n  var {\r\n    needClip\r\n  } = useNeedsClip(xAxisId, yAxisId);\r\n  var plotArea = usePlotArea();\r\n  var layout = useChartLayout();\r\n  var isPanorama = useIsPanorama();\r\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));\r\n  if (layout !== 'horizontal' && layout !== 'vertical' || points == null || plotArea == null) {\r\n    // Cannot render Line in an unsupported layout\r\n    return null;\r\n  }\r\n  var {\r\n    height,\r\n    width,\r\n    x: left,\r\n    y: top\r\n  } = plotArea;\r\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\r\n    id: id,\r\n    connectNulls: connectNulls,\r\n    dot: dot,\r\n    activeDot: activeDot,\r\n    animateNewValues: animateNewValues,\r\n    animationBegin: animationBegin,\r\n    animationDuration: animationDuration,\r\n    animationEasing: animationEasing,\r\n    isAnimationActive: isAnimationActive,\r\n    hide: hide,\r\n    label: label,\r\n    legendType: legendType,\r\n    xAxisId: xAxisId,\r\n    yAxisId: yAxisId,\r\n    points: points,\r\n    layout: layout,\r\n    height: height,\r\n    width: width,\r\n    left: left,\r\n    top: top,\r\n    needClip: needClip\r\n  }));\r\n}\r\nexport function computeLinePoints(_ref7) {\r\n  var {\r\n    layout,\r\n    xAxis,\r\n    yAxis,\r\n    xAxisTicks,\r\n    yAxisTicks,\r\n    dataKey,\r\n    bandSize,\r\n    displayedData\r\n  } = _ref7;\r\n  return displayedData.map((entry, index) => {\r\n    // @ts-expect-error getValueByDataKey does not validate the output type\r\n    var value = getValueByDataKey(entry, dataKey);\r\n    if (layout === 'horizontal') {\r\n      var _x = getCateCoordinateOfLine({\r\n        axis: xAxis,\r\n        ticks: xAxisTicks,\r\n        bandSize,\r\n        entry,\r\n        index\r\n      });\r\n      var _y = isNullish(value) ? null : yAxis.scale(value);\r\n      return {\r\n        x: _x,\r\n        y: _y,\r\n        value,\r\n        payload: entry\r\n      };\r\n    }\r\n    var x = isNullish(value) ? null : xAxis.scale(value);\r\n    var y = getCateCoordinateOfLine({\r\n      axis: yAxis,\r\n      ticks: yAxisTicks,\r\n      bandSize,\r\n      entry,\r\n      index\r\n    });\r\n    if (x == null || y == null) {\r\n      return null;\r\n    }\r\n    return {\r\n      x,\r\n      y,\r\n      value,\r\n      payload: entry\r\n    };\r\n  }).filter(Boolean);\r\n}\r\nfunction LineFn(outsideProps) {\r\n  var props = resolveDefaultProps(outsideProps, defaultLineProps);\r\n  var isPanorama = useIsPanorama();\r\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\r\n    id: props.id,\r\n    type: \"line\"\r\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\r\n    legendPayload: computeLegendPayloadFromAreaData(props)\r\n  }), /*#__PURE__*/React.createElement(SetLineTooltipEntrySettings, {\r\n    dataKey: props.dataKey,\r\n    data: props.data,\r\n    stroke: props.stroke,\r\n    strokeWidth: props.strokeWidth,\r\n    fill: props.fill,\r\n    name: props.name,\r\n    hide: props.hide,\r\n    unit: props.unit,\r\n    tooltipType: props.tooltipType,\r\n    id: id\r\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\r\n    type: \"line\",\r\n    id: id,\r\n    data: props.data,\r\n    xAxisId: props.xAxisId,\r\n    yAxisId: props.yAxisId,\r\n    zAxisId: 0,\r\n    dataKey: props.dataKey,\r\n    hide: props.hide,\r\n    isPanorama: isPanorama\r\n  }), /*#__PURE__*/React.createElement(LineImpl, _extends({}, props, {\r\n    id: id\r\n  }))));\r\n}\r\n\r\n/**\r\n * @provides LabelListContext\r\n * @provides ErrorBarContext\r\n * @consumes CartesianChartContext\r\n */\r\nexport var Line = /*#__PURE__*/React.memo(LineFn, propsAreEqual);\r\nLine.displayName = 'Line';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}